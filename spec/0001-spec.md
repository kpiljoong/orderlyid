# OrderlyID Specification (v0.1-draft)

## 1. Motivation

OrderlyID provides typed, time-sortable, globally unique identifiers optimized for distributed systems and developer ergonomics.

---

## 2. Terminology

- **Prefix** — lowercase type label identifying the entity (e.g., `order`, `user`).  
- **Payload** — 160-bit binary body, Base32 (Crockford) encoded into 32 chars.  
- **Checksum** — optional 4-character integrity check, computed with Bech32 polymod (20 bits) over `"<prefix>_<payload>"` and encoded in Crockford Base32.

---

## 3. Canonical String Form

```
<prefix>_<payload>[-<checksum>]
```

- `prefix` MUST match regex `^[a-z][a-z0-9]{1,30}$`.  
- Separator `_` MUST appear exactly once.  
- `payload` MUST be exactly 32 Crockford Base32 characters.  
- Canonical output is lowercase; parsers SHOULD accept mixed case.  
- If present, `checksum` MUST be 4 chars and MUST validate.

---

## 4. Binary Layout (160 bits, big-endian)

```
| 48b time | 8b flags | 16b tenant | 12b seq | 16b shard | 60b random |
```

- **time** — 48-bit unsigned, value = `unix_ms - 1577836800000` (2020-01-01T00:00:00Z). Range ~8.9k years.  
- **flags** — bits7..6 = wire version (00=v1); bit5 = privacy bucket; bits4..0 = reserved.  
- **tenant** — 16-bit unsigned. Optional tenant/routing id.  
- **seq** — 12-bit unsigned (0–4095). Per-process counter for same-ms bursts; wrap allowed.  
- **shard** — 16-bit unsigned. Optional routing/storage hint.  
- **random** — 60 bits of CSPRNG entropy.

---

## 5. Encoding

- Alphabet: Crockford Base32 (`0123456789abcdefghjkmnpqrstvwxyz`).  
- Input: 160-bit body, packed big-endian into 20 bytes.  
- Output: exactly 32 chars; no padding.  
- Canonical output is lowercase.

---

## 6. Checksum

1. `now_ms = system_clock_ms()`. If privacy enabled, quantize.  
2. If another ID in the same ms: increment 12-bit seq; wrap allowed.  
3. Draw 60 bits from CSPRNG.  
4. Pack fields into 160-bit body, encode to 32 Base32 chars.  
5. Emit `"<prefix>_<payload>"`; append checksum if configured.

*Ordering semantics*: within same prefix, lexicographic sort ≈ `(time, flags, tenant, seq, shard, random)`.

## 7. Generation

1. `now_ms = system_clock_ms()`. If privacy enabled, quantize.  
2. If another ID in the same ms: increment 12-bit seq; wrap allowed.  
3. Draw 60 bits from CSPRNG.  
4. Pack fields into 160-bit body, encode to 32 Base32 chars.  
5. Emit `"<prefix>_<payload>"`; append checksum if configured.

*Ordering semantics*: within same prefix, lexicographic sort ≈ `(time, flags, tenant, seq, shard, random)`.

---

## 8. Parsing & Validation

- Split at `'-'`; if checksum present, validate.  
- Split at `'_'`; if absent, reject.  
- Validate prefix regex.  
- Ensure payload length = 32; chars in Crockford alphabet.  
- Decode to 20 bytes; unpack per layout.  
- Reject unknown wire versions (flags bits7..6).  
- Return prefix, decoded fields, and binary body.

---

## 9. Security & Privacy

- IDs reveal coarse creation time. Use privacy bucket flag if needed.  
- Random field MUST come from a cryptographically secure RNG.  
- Checksum protects against transcription errors only.

---

## 10. Interop & Tests

- **SQL**: store `id_text VARCHAR(64)` and `id_bin BINARY(20)`; index `id_bin` for range scans.  
- **DynamoDB**: use as sort key; shard global feeds via virtual partitions.  
- **APIs/logs**: emit typed ID with checksum externally; redact tail if sensitive.  
- **Conformance**: implementations claiming v1 MUST:
  - emit canonical lowercase strings,
  - accept mixed-case input,
  - validate checksum if present,
  - reject unknown wire versions,
  - pass `spec/test-vectors.json`,
  - preserve lexicographic ordering semantics.
